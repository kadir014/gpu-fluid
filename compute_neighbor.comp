#version 460


#define PARTICLE_N 1
#define CELL_N 1
#define CELL_SIZE 1.0
#define GRID_WIDTH 1
#define GRID_HEIGHT 1


layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 6) readonly buffer particles_in {
    vec2 position_in[PARTICLE_N];
    vec2 velocity_in[PARTICLE_N];
};

layout(std430, binding = 7) writeonly buffer particles_out {
    vec2 position_out[PARTICLE_N];
    vec2 velocity_out[PARTICLE_N];
};

layout(std430, binding = 4) readonly buffer sorted_entries_in {
    uint sorted_cell_id[PARTICLE_N];
    uint sorted_particle_id[PARTICLE_N];
};

layout(std430, binding = 5) readonly buffer cell_ranges_in {
    uint cell_start[CELL_N];
    uint cell_end[CELL_N];
};

void main() {
    uint id = gl_GlobalInvocationID.x;
    if (id >= PARTICLE_N) return;

    vec2 position = position_in[id];
    vec2 velocity = velocity_in[id];

    ivec2 base_cell = ivec2(floor(position / CELL_SIZE));

    for (int y = -1; y <= 1; y++) {
        for (int x = -1; x <= 1; x++) {
            // calculate cell id
            // calculate start & end
            ivec2 neighbor_cell = base_cell + ivec2(x, y);
            neighbor_cell.x = clamp(neighbor_cell.x, 0, GRID_WIDTH - 1);
            neighbor_cell.y = clamp(neighbor_cell.y, 0, GRID_HEIGHT - 1);

            uint neighbor_cell_id = neighbor_cell.x + neighbor_cell.y * GRID_WIDTH;

            uint start = cell_start[neighbor_cell_id];
            uint end = cell_end[neighbor_cell_id];

            for (uint i = start; i < end; i++) {
                uint neighbor_id = sorted_particle_id[i];

                // Skip self interaction
                if (neighbor_id == id) continue;
            }
        }
    }

    velocity_out[id] = velocity;
}